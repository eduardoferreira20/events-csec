função ECB (count, dataCodewords) {this.count = count, this.dataCodewords = dataCodewords, isto .__ defineGetter__ ("Count", function () {return this.count}), isto .__ defineGetter __ ("DataCodewords", function () {return this.dataCodewords})} ECBlocks (ecCodewordsPerBlock, ecBlocks1, ecBlocks2) {this.ecCodewordsPerBlock = ecCodewordsPerBlock, ecBlocks2? this.ecBlocks = novo Array (ecBlocks1, ecBlocks2): this.ecBlocks = new Array (ecBlocks1), este. __defineGetter __ ("ECCodewordsPerBlock", function () {retornar this.ecCodewordsPerBlock}), isto .__ defineGetter __ ("TotalECCodewords", function () {retornar this.ecCodewordsPerBlock * this.NumBlocks}), isto .__ defineGetter __ ("NumBlocks", função ( ) {para (var total = 0, i = 0; i <this.ecBlocks.length; i ++) total + = this.ecBlocks [i] .length; retorno total}), this.getECBlocks = function () {retorne isso.Versão do ecBlocks}} (versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4) {this.versionNumber = número_da_versão, this.alignmentPatternCenters = alignmentPatternCenters, this.ecBlocks = nova Matriz (ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4); total = 0, ecCodewords = ecBlocks1.ECCodewordsPerBlock, ecbArray = ecBlocks1.getECBlocks (), i = 0; i <ecbArray.length; i ++) {var ecBlock = ecbArray [i]; total + = ecBlock.Count * (ecBlock.DataCodewords + ecCodewords)} this.totalCodewords = total, isto .__ defineGetter __ ("VersionNumber", function () {retornar this.versionNumber}), isto .__ defineGetter__ ("AlignmentPatternCenters", function () {return this.alignmentPatternCenters}), isto .__ defineGetter__ ("TotalCodewords", function () {return this.totalCodewords}), isto .__ defineGetter __ ("DimensionForVersion", function () {retornar 17 + 4 * isto.versionNumber}), this.buildFunctionPattern = function () {var dimensão = this.DimensionForVersion, bitMatrix = new BitMatrix (dimensão); bitMatrix.setRegion (0,0,9,9), bitMatrix.setRegion (dimensão-8,0, 8,9), bitMatrix.setRegion (0, dimensão-8,9,8); para (var max = this.alignmentPatternCenters.length, x = 0; max> x; x ++) para (var i = this.alignmentPatternCenters [ x] -2, y = 0; max> y; y ++) 0 == x && (0 == y || y == max-1) || x == max-1 && 0 == y || bitMatrix.setRegion ( this.alignmentPatternCenters [y] -2, i, 5,5); retorno bitMatrix.setRegion (6,9,1, dimensão-17), bitMatrix.setRegion (9,6, dimensão-17,1), this.versionNumber > 6 && (bitMatrix.setRegion (dimensão-11,0,3,6), bitMatrix.setRegion (0, dimensão-11,6,3)), bitMatrix}, this.getECBlocksForLevel = function (ecLevel) {return this.ecBlocks [ecLevel.ordinal ()]}} function buildVersions () {return new Array (nova versão (1, nova matriz, novos ECBlocks (7,novo BCE (1,19)), novos BCE (10, novo BCE (1,16)), novos BCE (13, novo BCE (1,13)), novos BCE (17, novo BCE (1,9)) ), nova versão (2, nova Matriz (6,18), novos ECBlocks (10, novo BCE (1,34)), novos ECBlocks (16, novo BCE (1,28)), novos ECBlocks (22, novo BCE (1,22)), novos ECBlocks (28, novo BCE (1,16))), nova versão (3, nova Matriz (6,22), novos ECBlocks (15, novo BCE (1,55)), nova ECBlocks (26, novo BCE (1,44)), novos ECBlocks (18, novo BCE (2,17)), novos ECBlocks (22, novo BCE (2,13))), nova versão (4, nova Matriz ( 6,26), novos ECBlocks (20, novo BCE (1,80)), novos ECBlocks (18, novo BCE (2,32)), novos ECBlocks (26, novo BCE (2,24)), novos ECBlocks ( 16, novo BCE (4,9))), nova versão (5, novo Array (6,30), novos ECBlocks (26, novo BCE (1,108)), novos ECBlocks (24, novo BCE (2,43)) , novos BCE (18, novo BCE (2,15), novo BCE (2,16)), novos BCE (22, novo BCE (2,11), novo BCE (2,12))), nova versão (6 , novo Array (6,34), novo ECBlocks (18, novo BCE (2,68)), novo ECBlocks (16, novo BCE (4,27)),novos ECBlocks (24, novo BCE (4,19)), novos ECBlocks (28, novo BCE (4,15))), nova versão (7, nova Matriz (6,22,38), novos ECBlocks (20, nova BCE (2,78)), novos BCE (18, novo BCE (4,31)), novos BCE (18, novo BCE (2,14), novo BCE (4,15)), novos ECBlocks (26, novo BCE (4,13), novo BCE (1,14))), nova versão (8, nova Matriz (6,24,42), novos ECBlocks (24, novo BCE (2,97)), novos ECBlocks (22 , novo BCE (2,38), novo BCE (2,39)), novos BCE (22, novo BCE (4,18), novo BCE (2,19)), novos BCE (26, novo BCE (4, 14), novo BCE (2,15))), nova versão (9, novo Array (6,26,46), novos ECBlocks (30, novo BCE (2,116)), novos ECBlocks (22, novo BCE (3, 36), novo BCE (2,37)), novos BCE (20, novo BCE (4,16), novo BCE (4,17)), novos BCE (24, novo BCE (4,12), novo BCE ( 4,13))), nova versão (10, nova Matriz (6,28,50), novos ECBlocks (18, novo BCE (2,68), novo BCE (2,69)), novos ECBlocks (26, novo BCE (4,43), novo BCE (1,44)), novos BCE (24, novo BCE (6,19), novo BCE (2,20)), novos BCE (28, novo BCE (6,15)) , novo BCE (2,16))), nova versão (11, nova Matriz (6,30,54), novos ECBlocos (20, novo BCE (4,81)), novos BCE (30, novo BCE (1,50), novo BCE ( 4,51)), novos BCE (28, novo BCE (4,22), novo BCE (4,23)), novos BCE (24, novo BCE (3,12), novo BCE (8,13))) , nova versão (12, nova Matriz (6,32,58), novos ECBlocks (24, novo BCE (2,92), novo BCE (2,93)), novos ECBlocks (22, novo BCE (6,36) , novo BCE (2,37)), novos BCE (26, novo BCE (4,20), novo BCE (6,21)), novos BCE (28, novo BCE (7,14), novo BCE (4, 15))), nova versão (13, nova Matriz (6,34,62), novos ECBlocks (26, novo BCE (4 007)), novos BCE (22, novo BCE (8,37), novo BCE (1, 38)), novos BCE (24, novo BCE (8,20), novo BCE (4,21)), novos BCE (22, novo BCE (12,11), novo BCE (4,12))), novo Versão (14, nova Matriz (6,26,46,66), novos BCEBlocks (30, novo BCE (3.115), novo BCE (1.116)), novos BCE (24, novo BCE (4,40), novo BCE ( 5,41)), novos BCE (20, novo BCE (11,16), novo BCE (5,17)), novos BCE (24, novo BCE (11,12), novo BCE (5,13))) ,nova versão (15, nova Matriz (6,26,48,70), novos BCEBlocks (22, novo BCE (5,87), novo BCE (1,88)), novos ECBlocks (24, novo BCE (5,41 ), novo BCE (5,42)), novos BCE (30, novo BCE (5,24), novo BCE (7,25)), novos BCE (24, novo BCE (11,12), novo BCE (7 , 13))), nova versão (16, nova Matriz (6,26,50,74), novos ECBlocks (24, novo BCE (5,98), novo BCE (1,99)), novos ECBlocks (28, novo BCE (7,45), novo BCE (3,46)), novos BCE (24, novo BCE (15,19), novo BCE (2,20)), novos BCE (30, novo BCE ), novo BCE (13,16))), nova versão (17, novo Array (6,30,54,78), novos ECBlocks (28, novo BCE (1.107), novo BCE (5.108)), novos ECBlocks ( 28, novo BCE (10,46), novo BCE (1,47)), novos BCE (28, novo BCE (1,22), novo BCE (15,23)), novos BCE (28, novo BCE , 14), novo BCE (17, 15))), nova versão (18, novo Array (6,30,56,82), novo BCE (30, novo BCE (5.120), novo BCE (1.121)), novo ECBlocks (26, novo BCE (9,43), novo BCE (4,44)), novos BCE (28, novo BCE (17,22), novo BCE (1,23)), novos ECBlocks (28,novo BCE (2,14), novo BCE (19,15))), nova versão (19, novo Array (6,30,58,86), novos ECBlocks (28, novo BCE (3,113), novo BCE )), novos BCE (26, novo BCE (3,44), novo BCE (11,45)), novos BCE (26, novo BCE (17,21), novo BCE (4,22)), novos ECBlocks ( 26, novo BCE (9,13), novo BCE (16,14))), nova versão (20, novo Array (6,34,62,90), novo ECBlocks (28, novo BCE (3 107), novo BCE (5.108)), novos BCE (26, novo BCE (3,41), novo BCE (13,42)), novos BCE (30, novo BCE (15,24), novo BCE (5,25)), novo ECBlocks (28, novo BCE (15,15), novo BCE (10,16))), nova versão (21, novo Array (6,28,50,72,94), novo ECBlocks (28, novo BCE ), novo BCE (4.117)), novos BCE (26, novo BCE (17,42)), novos BCE (28, novo BCE (1722), novo BCE (6,23)), novos BCE (30, novo BCE (19,16), novo BCE (6,17))), nova versão (22, novo Array (6,26,50,74,98), novo BCE (28, novo BCE (2 111), novo BCE (7,112)), novos ECBlocks (28, novo BCE (17,46)), novos ECBlocks (30, novo BCE (7,24), novo BCE (16,25)),novos BCE (24, novo BCE (34,13))), nova versão (23, novo Array (6,30,54,74,102), novos BCE (30, novo BCE (4.121), novo BCE (5122)), novos BCE (28, novo BCE (4,47), novo BCE (14,48)), novos BCE (30, novo BCE (11,24), novo BCE (14,25)), novos BCE (30 novos BCE (16,15), novo BCE (14,16))), nova versão (24, novo Array (6,28,54,80,106), novo BCE (30, novo BCE (6117), novo BCE (4,118) ), novos BCE (28, novo BCE (6,45), novo BCE (14,46)), novos BCE (30, novo BCE (11,24), novo BCE (16,25)), novos BCE (30 , novo BCE (30,16), novo BCE (2,17))), nova versão (25, nova Matriz (6,32,58,84,110), novos BCE (26, novo BCE (8 106), novo BCE ( 4.107)), novos BCE (28, novo BCE (8,47), novo BCE (13,48)), novos BCE (30, novo BCE (7,24), novo BCE (22,25)), novos ECBlocks (30, novo BCE (22,15), novo BCE (13,16))), nova versão (26, novo Array (6,30,58,86,114), novos ECBlocks (28, novo BCE (10 114), novo BCE (2.115)), novos ECBlocks (28, novo BCE (19,46), novo BCE (4,47)),novos BCE (28, novo BCE (28,22), novo BCE (6,23)), novos BCE (30, novo BCE (33,16), novo BCE (4,17))), nova versão (27, novo Array (6,34,62,90,118), novo ECBlocks (30, novo BCE (8.122), novo BCE (4,123)), novo ECBlocks (28, novo BCE (22,45), novo BCE (3,46) ), novos BCE (30, novo BCE (8,23), novo BCE (26,24)), novos BCE (30, novo BCE (12,15), novo BCE (28,16))), nova versão ( 28, novo Array (6,26,50,74,98,122), novo ECBlocks (30, novo BCE (3.117), novo BCE (10.118)), novos BCE (28, novo BCE (3,45), novo BCE ( 23,46)), novos BCE (30, novo BCE (4,24), novo BCE (31,25)), novos BCE (30, novo BCE (11,15), novo BCE (31,16))) , nova versão (29, novo Array (6,30,54,78,102,126), novo ECBlocks (30, novo BCE (7.116), novo BCE (7.117)), novo ECBlocks (28, novo BCE (21,45), novo BCE (7,46)), novos BCE (30, novo BCE (1,23), novo BCE (37,24)), novos BCE (30, novo BCE (19,15), novo BCE (26,16) )), nova versão (30, nova Matriz (6,26,52,78,104,130), novos ECBlocks (30, novo BCE (5,115), novo BCE (10.116)), novos BCE (28, novo BCE (19,47), novo BCE (10,48)), novos BCE (30, novo BCE (15,24), novo BCE (25, 25)), novos ECBlocks (30, novo BCE (23,15), novo BCE (25,16))), nova versão (31, novo Array (6,30,56,82,108,134), novos ECBlocks (30, novo BCE (13.115), novo BCE (3.116)), novos BCE (28, novo BCE (2,46), novo BCE (29,47)), novos BCE (30, novo BCE (42,24), novo BCE ( 1,25)), novos ECBlocks (30, novo BCE (23,15), novo BCE (28,16))), nova versão (32, novo Array (6,34,60,86,112,138), novos ECBlocks (30 , novo BCE (17)), novos BCE (28, novo BCE (10,46), novo BCE (23,47)), novos BCE (30, novo BCE (10,24), novo BCE (35,25) ), novos BCE (30, novo BCE (19,15), novo BCE (35,16))), nova versão (33, novo Array (6,30,58,86,114,142), novos ECBlocks (30, novo BCE 17,115), novo BCE (1,116)), novos BCE (28, novo BCE (14,46), novo BCE (21,47)), novos BCE (30, novo BCE (29,24), novo BCE (19, 25)), novos BCE (30, novo BCE (11,15), novo BCE (46,16))),nova versão (34, novo Array (6,34,62,90,118,146), novo ECBlocks (30, novo BCE (13.115), novo BCE (6.116)), novo BCE (28, novo BCE (14 46), novo BCE (23,47), novos BCE (30, novo BCE (44,24), novo BCE (7,25)), novos BCE (30, novo BCE (59,16), novo BCE (1,17)) ), nova versão (35, novo Array (6,30,54,78,102,126,150), novo ECBlocks (30, novo BCE (12.121), novo BCE (7.122)), novo BCE (28, novo BCE (12,47), novo BCE (26,48)), novos BCE (30, novo BCE (39,24), novo BCE (14,25)), novos BCE (30, novo BCE (22,15), novo BCE (41,16 ))), nova versão (36, nova Matriz (6,24,50,76,102,128,154), novos BCE (30, novo BCE (6.121), novo BCE (14 14)), novos BCE (28, novo BCE (6,47) ), novo BCE (34,48)), novos BCE (30, novo BCE (46,24), novo BCE (10,25)), novos BCE (30, novo BCE (2,15), novo BCE (64 , 16))), nova versão (37, novo Array (6,28,54,80,106,132,158), novos ECBlocks (30, novo BCE (17.122), novo BCE (4.123)), novos ECBlocks (28, novo BCE , 46), novo BCE (14,47)),novos BCE (30, novo BCE (49,24), novo BCE (10,25)), novos BCE (30, novo BCE (24,15), novo BCE (46,16))), nova versão (38, novo Array (6,32,58,84,110,136,162), novo ECBlocks (30, novo BCE (4,122), novo BCE (18123)), novo BCE (28, novo BCE (13,46), novo BCE (32,47) ), novos BCE (30, novo BCE (48,24), novo BCE (14,25)), novos BCE (30, novo BCE (42,15), novo BCE (32,16))), nova versão ( 39, novo Array (6,26,54,82,110,138,166), novo ECBlocks (30, novo BCE (20.117), novo BCE (4.118)), novo ECBlocks (28, novo BCE (40,47), novo BCE (7, 48)), novos BCE (30, novo BCE (43,24), novo BCE (22,25)), novos BCE (30, novo BCE (10,15), novo BCE (67,16))), novo Versão (40, novo Array (6,30,58,86,114,142,170), novo ECBlocks (30, novo BCE (19.118), novo BCE (6.119)), novo BCE (28, novo BCE (18,47), novo BCE ( 31,48)), novos BCE (30, novo BCE (34,24), novo BCE (34,25)), novos BCE (30, novo BCE (20,15), novo BCE (61,16))) )} function PerspectiveTransform (a11, a21, a31, a12,a22, a32, a13, a23, a33) {this.a11 = a11, this.a12 = a12, this.a13 = a13, this.a21 = a21, this.a22 = a22, this.a23 = a23, this.a31 = a31, this.a32 = a32, this.a33 = a33, this.transformPoints1 = função (pontos) {para (var max = points.length, a11 = this.a11, a12 = this.a12, a13 = this.a13 , a21 = isto.a21, a22 = isto.a22, a23 = isto.a23, a31 = isto.a31, a32 = isto.a32, a33 = isto.a33, i = 0; max> i; i + = 2) { var x = pontos [i], y = pontos [i + 1], denominador = a13 * x + a23 * y + a33; pontos [i] = (a11 * x + a21 * y + a31) / denominador, pontos [ i + 1] = (a12x + a22x + a32) / denominador}}, this.transformPoints2 = function (xValues, yValues) {para (var n = xValues.length, i = 0; n> i; i ++ ) {var x = xValores [i], y = yValores [i], denominador = this.a13 * x + this.a23 * y + this.a33; xValores [i] = (this.a11 * x + this.a21 * y + this.a31) / denominador, yValores [i] = (this.a12 * x + isto.a22 * y + isto.a32) / denominador}}, this.buildAdjoint = function () {return new PerspectiveTransform (isto .a22 * this.a33-this.a23 * this.a32, isso.a23 * this.a31-this.a21 * this.a33, this.a21 * this.a32-this.a22 * this.a31, this.a13 * this.a32-this.a12 * this.a33, this.a11 * this.a33-this.a13 * this.a31, this.a12 * this.a31-this.a11 * this.a32, this.a12 * this.a23-this.a13 * this.a22, this.a13 * isso. a21-this.a11 * this.a23, this.a11 * this.a22-this.a12 * this.a21)}, this.times = function (other) {retornar novo PerspectiveTransform (this.a11 * other.a11 + this .a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * outros .a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + esta .a33 * outro.a33)}} function DetectorResult (bits, pontos) {this.bits = bits, this.points = pontos} function Detector (imagem) {this.image = image, this.resultPointCallback = null, this.sizeOfBlackWhiteBlackRun = function (fromX, fromY, toX, toY) {var steep = Math.abs (toY-fromY)> Math.abs (toX-fromX); if (steep) {var temp = fromX; fromX = fromY, fromY = temp, temp = toX, toX = toY, toY = temp} para (var dx = Math.abs (toX-fromX), dy = Math.abs (toY-fromY), error = -dx >> 1, ystep = toY> fromY? 1: - 1, xstep = toX> fromX? 1: -1, state = 0, x = fromX, y = fromY; x! = ToX; x + = xstep) {var realX = íngreme? Y: x, realY = íngreme? X: y; if (1 == estado? this.image [realX + realY * qrcode.width] && estado ++: this.image [realX + realY * qrcode.width] || estado ++, 3 == estado) {var diffX = x- fromX, diffY = y-fromY; retorna Math.sqrt (diffX * diffX + diffY * diffY)} if (erro + = dy, erro> 0) {if (y == paraY) quebra; y + = ystep, erro- = dx }} var diffX2 = toX-fromX, diffY2 = toY-fromY e retorna Math.sqrt (diffX2 * diffX2 + diffY2 * diffY2)}, this.sizeOfBlackWhiteBlackRunBothWays = função (fromX, fromY, toX, toY) {resultado var = this.sizeOfBlackWhiteBlackRun (fromX, fromY, toX, toY), scale = 1, otherToX = fromX - (toX-fromX); 0> otherToX? (escala = fromX / (fromX-otherToX), otherToX = 0): otherToX> = qrcode.width && (scale = (qrcode.width-1-fromX) / (otherToX-fromX ), otherToX = qrcode.width-1); var otherToY = Math.floor (fromY- (toY-fromY) * scale); escala de retorno = 1,0> otherToY? (scale = fromY / (fromY-otherToY), otherToY = 0): otherToY> = qrcode.height && (scale = (qrcode.height-1-fromY) / (otherToY-fromY), otherToY = qrcode.height-1), otherToX = Math.floor (deX + (otherToX-fromX) * escala), resultado + = this.sizeOfBlackWhiteBlackRun (fromX, fromY, otherToX, otherToY), resultado-1}, this.calculateModuleSizeOneWay = function (padrão, otherPattern) {var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays (Math.floor (padrão).X), Math.floor (padrão.Y), Math.floor (otherPattern.X), Math.floor (otherPattern.Y)), moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays (Math.floor (otherPattern.X), Math.floor ( otherPattern.Y), Math.floor (pattern.X), Math.floor (padrão.Y)); return isNaN (moduleSizeEst1)? moduleSizeEst2 / 7: isNaN (moduleSizeEst2)? moduleSizeEst1 / 7: (moduleSizeEst1 + moduleSizeEst2) / 14 }, this.calculateModuleSize = function (topLeft, topRight, bottomLeft) {retorno (this.calculateModuleSizeOneWay (topLeft, topRight) + this.calculateModuleSizeOneWay (topLeft, bottomLeft)) / 2}, this.distance = function (pattern1, pattern2) { return xDiff = pattern1.X-pattern2.X, yDiff = pattern1.Y-pattern2.Y, Math.sqrt (xDiff * xDiff + yDiff * yDiff)}, this.computeDimension = função (topLeft, topRight, bottomLeft, moduleSize) { var tltrCentersDimension = Math.round (this.distance (topLeft, topRight) / moduleSize), tlblCentersDimension = Math.round (isso.distância (topLeft, bottomLeft) / moduleSize), dimensão = (tltrCentersDimension + tlblCentersDimension >> 1) +7; switch (3 & dimensão) {caso 0: dimensão ++; quebra; caso 2: dimensão -; quebra; caso 3: lançamento "Erro "} retornar dimensão}, this.findAlignmentInRegion = function (overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {permissão var = Math.floor (allowanceFactor * overallEstModuleSize), alignmentAreaLeftX = Math.max (0, estAlignmentX-allowance), alignmentAreaRightX = Math. min (qrcode.width-1, estAlignmentX + permissão); if (3 * overallEstModuleSize> alignmentAreaRightX-alignmentAreaLeftX) lance "Erro"; var alignmentAreaTopY = Math.max (0, estAlignmentY-allowance), alignmentAreaBottomY = Math.min (qrcode. height-1, estAlignmentY + permissão), alignmentFinder = new AlignmentPatternFinder (this.image, alignmentAreaLeftX, alignmentAreaTopY,alignmentAreaRightX-alignmentAreaLeftX, alignmentAreaBottomY-alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback); return alignmentFinder.find ()}, this.createTransform = função (topLeft, topRight, bottomLeft, alignmentPattern, dimensão) {var bottomRightX, bottomRightY, sourceBottomRightX, sourceBottomRightY, dimMinusThree = dimensão-3.5; null! = alignmentPattern? (bottomRightX = alignmentPattern.X, bottomRightY = alignmentPattern.Y, sourceBottomRightX = fonteBottomRightY = dimMinusThree-3) :( bottomRightX = topRight.X-topLeft.X + bottomLeft.X, bottomRightY = topRight .Y-topLeft.Y + bottomLeft.Y, sourceBottomRightX = fonteBottomRightY = dimMinusThree); var transform = PerspectiveTransform.quadrilateralToQuadrilateral (3.5.3.5, dimMinusThree, 3.5, fonteBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight .X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X,bottomLeft.Y); return transform}, this.sampleGrid = função (imagem, transformação, dimensão) {var sampler = GridSampler; return sampler.sampleGrid3 (imagem, dimensão, transformação)}, this.processFinderPatternInfo = function (info) {var topLeft = info.TopLeft, topRight = info.TopRight, bottomLeft = info.BottomLeft, moduleSize = this.calculateModuleSize (topLeft, topRight, bottomLeft); if (1> moduleSize) lance "Erro"; var dimensão = this.computeDimension (topLeft , topRight, bottomLeft, moduleSize), provisionalVersion = Versão.getProvisionalVersionForDimension (dimensão), modulesBetweenFPCenters = provisionalVersion.DimensionForVersion-7, alignmentPattern = null; if (provisionalVersion.AlignmentPatternCenters.length> 0) para (var bottomRightX = topRight.X-topLeft. X + bottomLeft.X, bottomRightY = topRight.Y-topLeft.Y + bottomLeft.Y, correctionToTopLeft = 1-3 / modulesBetweenFPCenters, estAlignmentX = Matemática.floor (topLeft.X + correctionToTopLeft * (bottomRightX-topLeft.X)), estAlignmentY = Math.floor (topLeft.Y + correcçãoToTopLeft * (bottomRightY-topLeft.Y)), i = 4; 16> = i; i << = 1) {alignmentPattern = this.findAlignmentInRegion (moduleSize, estAlignmentX, estAlignmentY, i); break} var pontos, transform = this.createTransform (topLeft, topRight, bottomLeft, alinhamentoPadrão, dimensão), bits = this.sampleGrid (this.image , transform, dimension); pontos de retorno = null == alignmentPattern? new Array (bottomLeft, topLeft, topRight): novo Array (bottomLeft, topLeft, topRight, alignmentPattern), novo DetectorResult (bits, pontos)}, this.detect = function () {var info = (new FinderPatternFinder) .findFinderPattern (this.image); retorne this.processFinderPatternInfo (info)}} function FormatInformation (formatInfo) {this.errorCorrectionLevel = ErrorCorrectionLevel.forBits (formatInfo >> 3 e 3), this.dataMask = 7 eformatInfo, this .__ defineGetter __ ("ErrorCorrectionLevel", function () {retornar this.errorCorrectionLevel}), isto .__ defineGetter __ ("DataMask", function () {retornar this.dataMask}), this.GetHashCode = function () {retornar a este .errorCorrectionLevel.ordinal () << 3 | dataMask}, this.Equals = função (o) {var outro = o; retorno this.errorCorrectionLevel == other.errorCorrectionLevel && this.dataMask == other.dataMask}} função ErrorCorrectionLevel (ordinal, bits, nome) {this.ordinal_Renamed_Field = ordinal, this.bits = bits, this.name = nome, isto .__ defineGetter __ ("Bits", function () {retornar this.bits}), isto .__ defineGetter __ ("Name", function () {return this.name}), this.ordinal = função () {return this.ordinal_Renamed_Field}} função BitMatrix (largura, altura) {if (altura || (altura = largura), 1> largura || 1 > altura) throw "Ambas as dimensões devem ser maiores que 0 "; this.width = width, this.height = height; var rowSize = largura >> 5; 0! = (31 & width) && rowSize ++, this.rowSize = rowSize, this.bits = new Matriz ( rowSize * height); para (var i = 0; i <this.bits.length; i ++) this.bits [i] = 0; isto .__ defineGetter __ ("Width", function () {return this.width}), isto .__ defineGetter __ ("Altura", function () {return this.height}), isto .__ defineGetter __ ("Dimensão", function () {if (this.width! = this.height) lance "Não é possível chamar getDimension ( ) em uma matriz não quadrada "; return this.width}), this.get_Renamed = função (x, y) {var = offset = y * this.rowSize + (x >> 5); retorno 0! = (1 & URShift (este .bits [offset], 31 & x))}, this.set_Renamed = função (x, y) {var = offset = y * this.rowSize + (x >> 5); this.bits [deslocamento] | = 1 << (31 & x )}, this.flip = function (x, y) {var deslocamento = y * isso.rowSize + (x >> 5); this.bits [deslocamento] ^ = 1 << (31 & x)}, this.clear = função () {para (var max = this.bits.length, i = 0; max> i ; i ++) this.bits [i] = 0}, this.setRegion = função (esquerda, superior, largura, altura) {if (0> superior || 0> esquerda) throw "Esquerda e superior devem ser não-negativas"; (1> altura || 1> largura) throw "Altura e largura devem ser pelo menos 1"; var right = left + width, bottom = superior + altura; if (bottom> this.height || right> this.width) throw "A região deve caber dentro da matriz", para (var y = top; bottom> y; y ++) para (var offset = y * this.rowSize, x = esquerda; direita> x; x ++) this.bits [offset + (x >> 5)] | = 1 << (31 & x)}} função DataBlock (numDataCodewords, codewords) {this.numDataCodewords = numDataCodewords, this.codewords = palavras de código, isto .__ defineGetter __ ("NumDataCodewords", function () {return this.numDataCodewords}), isto .__ defineGetter __ ("Palavras-chave ", function () {return this.codewords})} função BitMatrixParser (bitMatrix) {var dimensão = bitMatrix.Dimension; if (21> dimensão || 1! = (3 & dimension)) throw" Erro BitMatrixParser "; this.bitMatrix = bitMatrix, this.parsedVersion = null, this.parsedFormatInfo = null, this.copyBit = função (i, j, versionBits) {retornar this.bitMatrix.get_Renamed (i, j)? versionBits << 1 | 1: versionBits << 1}, this.readFormatInformation = function () {if (null! = This.parsedFormatInfo) retorna this.parsedFormatInfo, para (var formatInfoBits = 0, i = 0; 6> i; i ++) formatInfoBits = this.copyBit (i, 8, formatInfoBits); formatInfoBits = this.copyBit (7,8, formatInfoBits), formatInfoBits = this.copyBit (8,8, formatInfoBits), formatInfoBits = this.copyBit (8,7, formatInfoBits); para (var j = 5 ; j> = 0; j -) formatInfoBits = this.copyBit (8, j, formatInfoBits); if (this.parsedFormatInfo = FormatInformation.decodeFormatInformation (formatInfoBits), null! = this.parsedFormatInfo) return this.parsedFormatInfo; var dimensão = this.bitMatrix.Dimension; formatInfoBits = 0; para (var iMin = dimensão-8, i = dimensão-1; i> = iMin; i -) formatInfoBits = this.copyBit (i, 8, formatInfoBits); para (var j = dimensão-7; dimensão> j; j ++) formatInfoBits = this.copyBit (8, j, formatInfoBits); if (this.parsedFormatInfo = FormatInformation.decodeFormatInformation (formatInfoBits), null! = This.parsedFormatInfo) retornar this.parsedFormatInfo; throw "Erro readFormatInformation"}, this.readVersion = function () {if (null! = This.parsedVersion) retornar this.parsedVersion; var dimension = this.bitMatrix.Dimension, provisionalVersion = dimension-17 >> 2; if (6> = provisionalVersion) retorna Version.getVersionForNumber (provisionalVersion); para (var versionBits = 0, ijMin = dimensão-11, j = 5; j > = 0; j -) para (var i = dimensão-9; i>= ijMin; i -) versionBits = this.copyBit (i, j, versionBits); if (this.parsedVersion = Version.decodeVersionInformation (versionBits), null! = this.parsedVersion && this.parsedVersion.DimensionForVersion == dimension) retornam isso. parsedVersion; versionBits = 0; para (var i = 5; i> = 0; i -) para (var j = dimensão-9; j> = ijMin; j -) versionBits = this.copyBit (i, j, if (this.parsedVersion = Version.decodeVersionInformation (versionBits), null! = this.parsedVersion && this.parsedVersion.DimensionForVersion == dimension) retornar this.parsedVersion; lançar "Error readVersion"}, this.readCodewords = function () { var formatInfo = this.readFormatInformation (), versão = this.readVersion (), dataMask = DataMask.forReference (formatInfo.DataMask), dimensão = this.bitMatrix.Dimension; dataMask.unmaskBitMatrix (this.bitMatrix, dimensão); functionPattern = version.buildFunctionPattern (),readingUp =! 0, result = new Matriz (version.TotalCodewords), resultOffset = 0, currentByte = 0, bitsRead = 0, j = dimensão-1; j> 0; j- = 2) {6 == j && j--; para (var count = 0; dimensão> contagem; contagem ++) para (var i = leituraUp? dimensão-1-contagem: contagem, col = 0; 2> col. col ++) functionPattern.get_Renamed (j-col, i) || (bitsRead ++, currentByte << = 1, this.bitMatrix.get_Renamed (j-col, i) && (currentByte | = 1), 8 == bitsLead && (resultado [resultOffset ++] = currentByte, bitsRead = 0, currentByte = 0)) leituraUp ^ =! 0} if (resultOffset! = version.TotalCodewords) throw "Erro readCodewords"; retorno resultado}} function DataMask000 () {this.unmaskBitMatrix = função (bits, dimensão) {para (var i = 0; dimensão > i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j, i)}, this.isMasked = função (i, j) {return 0 = função = (i + j & 1)}} DataMask001 () {this.unmaskBitMatrix = function (bits,dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j, i)}, this.isMasked = function (i, j) {retornar 0 == (1 & i)}} function DataMask010 () {this.unmaskBitMatrix = função (bits, dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j, i)}, this.isMasked = função (i, j) {retorno j% 3 == 0}} função DataMask011 ( ) {this.unmaskBitMatrix = função (bits, dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j, i)}, this.isMasked = função (i, j) {retorno (i + j)% 3 == 0}} function DataMask100 () {this.unmaskBitMatrix = função (bits, dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j, i)}, this.isMasked = function (i, j ) {return 0 == (URShift (i, 1) + j / 3 &1)}} function DataMask101 () {this.unmaskBitMatrix = função (bits, dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked ( i, j) && bits.flip (j, i)}, this.isMasked = função (i, j) {var temp = i * j; retorno (1 & temp) + temp% 3 == 0}} função DataMask110 () { this.unmaskBitMatrix = função (bits, dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j , i)}, this.isMasked = função (i, j) {var temp = i * j; retorno 0 == ((1 & temp) + temp% 3 & 1)}} função DataMask111 () {this.unmaskBitMatrix = function (bits , dimensão) {para (var i = 0; dimensão> i; i ++) para (var j = 0; dimensão> j; j ++) this.isMasked (i, j) && bits.flip (j, i)}, isto. isMasked = função (i, j) {retorno 0 == ((i + j & 1) + i * j% 3 & 1)}} function ReedSolomonDecoder (campo) {this.field = field, this.decode = function (recebido,twoS) {para (var poly = new GF256Poli (this.field, received), syndromeCoefficients = new Matriz (doisS), i = 0; i <syndromeCoefficients.length; i ++) syndromeCoefficients [i] = 0; para (var dataMatrix = ! 1, noError =! 0, i = 0; doisS> i; i ++) {vareval = poly.evaluateAt (this.field.exp (dataMatrix? I + 1: i)); syndromeCoefficients [syndromeCoefficients.length-1- i] = eval, 0! = eval && (noError =! 1)} if (! noError) para (var syndrome = new GF256Poly (this.field, syndromeCoefficients), sigmaOmega = this.runEuclideanAlgorithm (this.field.buildMonomial (dois, 1), síndrome, dois S), sigma = sigmaOmega [0], omega = sigmaOmega [1], errorLocations = isto.findErrorLocations (sigma), errorMagnitudes = this.findErrorMagnitudes (omega, errorLocations, dataMatrix), i = 0; i < errorLocations.length; i ++) {var position = recebeu.length-1-this.field.log (errorLocations [i]); if (0> posição) throw "ReedSolomonException Local de erro incorreto";recebeu [position] = GF256.addOrSubtract (recebeu [position], errorMagnitudes [i])}}, this.runEuclideanAlgorithm = function (a, b, R) {se (a.Degree <b.Degree) {var temp = a ; a = b, b = temp} para (var rLast = a, r = b, sÚltimo = this.field.One, s = this.field.Zero, tLast = this.field.Zero, t = this.field. Um; r.Degree> = Math.floor (R / 2);) {var rLastLast = rLast, sLastLast = sLast, tLastLast = tLast; if (rLast = r, sLast = s, tLast = t, rLast.Zero) throw "r_ {i-1} era zero"; r = rLastLast; para (var q = this.field.Zero, denominatorLeadingTerm = rLast.getCoefficient (rLast.Degree), dltInverse = this.field.inverso (denominatorLeadingTerm); r. Grau> = rLast.Degree &&! R.Zero;) {var degreeDiff = r.Degree-rLast.Degree, scale = this.field.multiply (r.getCoefficient (r.Degree), dltInverse); q = q.addOrSubtract ( this.field.buildMonomial (degreeDiff, scale)), r = r.addOrSubtract (rLast.multiplyByMonomial (degreeDiff, scale))} s = q.multiplply1 (sLast) .addOrSubtract (sLastLast), t = q.multiply1 (tLast) .addOrSubtract (tLastLast)} var sigmaTidAtZero = t.getCoefficient (0); se (0 == sigmaTildeAtZero) lance "ReedSolomonException sigmaTilde (0) era zero "; var inverso = this.field.inverse (sigmaTildeAtZero), sigma = t.multiply2 (inverso), omega = r.multiply2 (inverso); return new Matriz (sigma, omega)}, this.findErrorLocations = function (errorLocator) {var numErrors = errorLocator.Degree; if (1 == numErrors) retorna um novo Array (errorLocator.getCoefficient (1)); para (var result = new Array (numErrors), e = 0, i = 1; 256> i && numErrors> e; i ++) 0 == errorLocator.evaluateAt (i) && (resultado [e] = this.field.inverse (i), e ++); if (e! = numErrors) throw "O grau do localizador de erros não corresponde ao número de raízes "; return result}, this.findErrorMagnitudes = function (errorEvaluator, errorLocations, dataMatrix) {para (var s = errorLocations.length,result = new Matriz (s), i = 0; s> i; i ++) {para (var xiInverse = this.field.inverse (errorLocations [i]), denominador = 1, j = 0; s> j; j ++) i! = j && (denominador = this.field.multiply (denominador, GF256.addOrSubtract (1, this.field.multiply (errorLocations [j], xiInverso)))); resultado [i] = this.field.multiply (errorEvaluator .evaluateAt (xiInverse), this.field.inverse (denominator)), dataMatrix && (resultado [i] = this.field.multiply (resultado [i], xiInverse))} resultado do retorno}} function GF256Poly (field, coefficients) { if (null == coefficients || 0 == coefficients.length) lance "System.ArgumentException"; this.field = campo; var coefficientsLength = coefficients.length; se (coefficientsLength> 1 && 0 == coeficientes [0]) {for ( var firstNonZero = 1; coefficientsLength> firstNonZero && 0 == coeficientes [firstNonZero];) firstNonZero ++; if (firstNonZero == coefficientsLength) this.coefficients = campo.Zero.coefficients; else {this.coefficients = new Matriz (coefficientsLength-firstNonZero); para (var i = 0; i <this.coefficients.length; i ++) this.coefficients [i] = 0; para (var ci = 0 ; ci <this.coefficients.length; ci ++) this.coefficients [ci] = coeficientes [firstNonZero + ci]}} else this.coefficients = coeficientes; isto .__ defineGetter __ ("Zero", function () {return 0 == this .coefficients [0]}), isto .__ defineGetter __ ("Grau", função () {return this.coefficients.length-1}), isto .__ defineGetter __ ("Coefficients", function () {return this.coefficients}), this.getCoefficient = function (degree) {retornar this.coefficients [this.coefficients.length-1-degree]}, this.evaluateAt = função (a) {if (0 == a) retorna this.getCoefficient (0); var size = this.coefficients.length; if (1 == a) {para (var resultado = 0, i = 0; tamanho> i; i ++) resultado = GF256.addOrSubtract (resultado, this.coefficients [i]);return result} para (var result2 = this.coefficients [0], i = 1; tamanho> i; i ++) resultado2 = GF256.addOrSubtract (this.field.multiply (a, result2), this.coefficients [i]); return result2}, this.addOrSubtract = function (other) {if (this.field! = outro.field) throw "GF256Polys não possuem o mesmo campo GF256", se (this.Zero) retorna outro; if (other.Zero) retorne isto: var smallerCoefficients = this.coefficients, largerCoefficients = other.coefficients; if (menorCoefficients.length> largerCoefficients.length) {var temp = menorCoefficients; smallerCoefficients = largerCoefficients, largerCoefficients = temp} para (var sumDiff = new Array (largerCoefficients). length), lengthDiff = maiorCoefficients.length-smallerCoefficients.length, ci = 0; lengthDiff> ci; ci ++) sumDiff [ci] = maiorCoefficients [ci]; para (var i = lengthDiff; i <largeCoefficients.length; i ++) sumDiff [ i] = GF256.addOrSubtract (smallerCoefficients [i-lengthDiff], maiorCoefficients [i]); retorna novo GF256Poly (campo, sumDiff)}, this.multiply1 = função (outro) {if (this.field! = other.field) lance "GF256Polys não tem o mesmo campo GF256 "; if (this.Zero || other.Zero) retorna this.field.Zero; para (var aCoefficients = this.coefficients, aLength = aCoefficients.length, bCoefficients = other.coefficients, bLength = bCoefficients.length , product = new Matriz (aLength + bLength-1), i = 0; aLength> i; i ++) para (var aCoeff = aCoefficients [i], j = 0; bComprimento> j; j ++) produto [i + j] = GF256.addOrSubtract (produto [i + j], this.field.multiply (aCoeff, bCoefficients [j])); return new GF256Poly (this.field, product)}, this.multiply2 = função (escalar) {if (0 == escalar) return this.field.Zero; if (1 == escalar) retorne isto, para (var size = this.coefficients.length, product = novo Array (tamanho), i = 0; tamanho> i; i ++) produto [i] = this.field.multiply (isso.coeficientes [i], escalar); return new GF256Poly (this.field, product)}, this.multiplyByMonomial = função (grau, coeficiente) {if (0> degree) throw "System.ArgumentException"; if (0 == coeficiente ) return this.field.Zero para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; var i = 0; tamanho> i; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); retorna novo GF256Poly (this.field, product)}, this.divide = function ( outro) {if (this.field! = other.field) throw "GF256Polys não tem o mesmo campo GF256", se (other.Zero) lança "Divide by 0", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {) {) {escalar); return new GF256Poly (this.field, product)}, this.multiplyByMonomial = função (grau, coeficiente) {if (0> degree) throw "System.ArgumentException"; if (0 == coeficiente) return this.field .Zero; para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); retorna novo GF256Poly (this.field, product)}, this.divide = function (outro) {if ( this.field! = other.field) throw "GF256Polys não tem o mesmo campo GF256", se (other.Zero) lançar "Divide by 0", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restoDegree> = other.Degree &&! remainder.Zero;) {escalar); return new GF256Poly (this.field, product)}, this.multiplyByMonomial = função (grau, coeficiente) {if (0> degree) throw "System.ArgumentException"; if (0 == coeficiente) return this.field .Zero; para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); retorna novo GF256Poly (this.field, product)}, this.divide = function (outro) {if ( this.field! = other.field) throw "GF256Polys não tem o mesmo campo GF256", se (other.Zero) lançar "Divide by 0", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restoDegree> = other.Degree &&! remainder.Zero;) {return new GF256Poly (this.field, product)}, this.multiplyByMonomial = função (grau, coeficiente) {if (0> grau) throw "System.ArgumentException"; if (0 == coeficiente) retorna this.field.Zero; para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i ; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); return new GF256Poly (this.field, product)}, this.divide = function (outro) {if (this.field ! = other.field) throw "GF256Polys não tem o mesmo campo GF256", se (other.Zero) lançar "Divide by 0", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {return new GF256Poly (this.field, product)}, this.multiplyByMonomial = função (grau, coeficiente) {if (0> grau) throw "System.ArgumentException"; if (0 == coeficiente) retorna this.field.Zero; para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i ; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); return new GF256Poly (this.field, product)}, this.divide = function (outro) {if (this.field ! = other.field) throw "GF256Polys não tem o mesmo campo GF256", se (other.Zero) lançar "Divide by 0", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {this.multiplyByMonomial = function (grau, coeficiente) {if (0> grau) throw "System.ArgumentException"; if (0 == coeficiente) retorna this.field.Zero; para (var size = this.coefficients.length, product = novo Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field. multiplique (this.coefficients [i], coeficiente); retorne novo GF256Poly (this.field, product)}, this.divide = function (outro) {if (this.field! = other.field) lance "GF256Polys não tem mesmo campo GF256 "; se (other.Zero) lançar" Divide by 0 ", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field. inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {this.multiplyByMonomial = function (grau, coeficiente) {if (0> grau) throw "System.ArgumentException"; if (0 == coeficiente) retorna this.field.Zero; para (var size = this.coefficients.length, product = novo Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field. multiplique (this.coefficients [i], coeficiente); retorne novo GF256Poly (this.field, product)}, this.divide = function (outro) {if (this.field! = other.field) lance "GF256Polys não tem mesmo campo GF256 "; se (other.Zero) lançar" Divide by 0 ", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field. inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {grau) throw "System.ArgumentException"; if (0 == coeficiente) retorne this.field.Zero; para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i < product.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); return new GF256Poly (this.field, product)}, this.divide = function (outro) {if (this.field! = other.field) throw "GF256Polys não possuem o mesmo campo GF256"; se (other.Zero) lançar "Divide by 0 "; para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restoDegree> = other.Degree &&! Restante .Zero;){grau) throw "System.ArgumentException"; if (0 == coeficiente) retorne this.field.Zero; para (var size = this.coefficients.length, product = new Matriz (tamanho + grau), i = 0; i < product.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field.multiply (this.coefficients [i], coeficiente); return new GF256Poly (this.field, product)}, this.divide = function (outro) {if (this.field! = other.field) throw "GF256Polys não possuem o mesmo campo GF256"; se (other.Zero) lançar "Divide by 0 "; para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restoDegree> = other.Degree &&! Restante .Zero;){produto = novo Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field .multiply (this.coefficients [i], coeficiente); return new GF256Poly (this.field, product)}, this.divide = função (outro) {if (this.field! = other.field) lance "GF256Polys não tem o mesmo campo GF256 "; se (other.Zero) lança" Divide by 0 ", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field .inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {produto = novo Matriz (tamanho + grau), i = 0; i <produto.length; i ++) produto [i] = 0; para (var i = 0; tamanho> i; i ++) produto [i] = this.field .multiply (this.coefficients [i], coeficiente); return new GF256Poly (this.field, product)}, this.divide = função (outro) {if (this.field! = other.field) lance "GF256Polys não tem o mesmo campo GF256 "; se (other.Zero) lança" Divide by 0 ", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field .inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {GF256Polys não tem o mesmo campo GF256 "; se (other.Zero) lança" Divide by 0 ", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {GF256Polys não tem o mesmo campo GF256 "; se (other.Zero) lança" Divide by 0 ", para (var quotient = this.field.Zero, resto = this, denominatorLeadingTerm = other.getCoefficient (other.Degree), inverseDenominatorLeadingTerm = this.field.inverse (denominatorLeadingTerm); restanteDegree> = other.Degree &&! remainder.Zero;) {
	var degreeDifference = restanteDegree-other.Degree, scale = this.field.multiply (remainder.getCoefficient (restanteDegree), inverseDenominatorLeadingTerm), term = other.multiplyByMonomial (degreeDifference, scale), iterationQuotient = this.field.buildMonomial ( degreeDifference, scale); quociente = quociente.addOrSubtract (iterationQuotient), resto = remainder.addOrSubtract (term)} retornar novo Array (quociente, resto)}} function GF256 (primitivo) {this.expTable = new Array (256), this .logTable = new Array (256); para (var x = 1, i = 0; 256> i; i ++) this.expTable [i] = x, x << = 1, x> = 256 && (x ^ = primitivo para (var i = 0; 255> i; i ++) this.logTable [this.expTable [i]] = i; var at0 = novo Array (1); at0 [0] = 0, this.zero = novo GF256Política (isto, nova Matriz (at0)); var at1 = new Matriz (1); at1 [0] = 1, this.one = new GF256Política (isto, nova Matriz (at1)), isto .__ defineGetter __ ("Zero" , function () {return this.zero}),this .__ defineGetter __ ("Um", function () {return this.one}), this.buildMonomial = função (grau, coeficiente) {if (0> degree) throw "System.ArgumentException"; if (0 == coeficiente) return zero; para (var coeficientes = new Matriz (grau + 1), i = 0; i <coeficientes.length; i ++) coeficientes [i] = 0; coeficientes de retorno [0] = coeficiente, novo GF256Política (isto, coeficientes) }, this.exp = function (a) {retornar this.expTable [a]}, this.log = function (a) {se (0 == a) lançar "System.ArgumentException"; retorne this.logTable [a] }, this.inverse = function (a) {se (0 == a) lançar "System.ArithmeticException"; retorne this.expTable [255-this.logTable [a]]}, this.multiply = function (a, b ) {return 0 == a || 0 == b? 0: 1 == a? b: 1 == b? a: this.expTable [(this.logTable [a] + esta.logTabela [b])% 255]}} função URShift (número, bits) {número de retorno> = 0? Número >> bits: (número >> bits) + (2 <<~ bits)} função FinderPattern (posX, posY, estimatedModuleSize) {this.x = posX, this.y = posY, this.count = 1, this.estimatedModuleSize = estimatedModuleSize, isto .__ defineGetter __ ("EstimatedModuleSize", function () { return this.estimatedModuleSize}), isto .__ defineGetter __ ("Count", function () {retornar this.count}), isto .__ defineGetter __ ("X", function () {retornar this.x}), isto .__ defineGetter __ (" Y ", function () {retornar this.y}), this.incrementCount = function () {this.count ++}, this.aboutEquals = function (moduleSize, i, j) {se (Math.abs (i-isso). y) <= moduleSize && Math.abs (j-this.x) <= moduleSize) {var moduleSizeDiff = Math.abs (moduleSize-this.estimatedModuleSize); return 1> = moduleSizeDiff || moduleSizeDiff / this.estimatedModuleSize <= 1} retornar ! 1}} function FinderPatternInfo (patternCenters) {this.bottomLeft = patternCenters [0], isto.topLeft = patternCenters [1], this.topRight = patternCenters [2], isto .__ defineGetter __ ("BottomLeft", function () {retornar this.bottomLeft}), isto .__ defineGetter __ ("TopLeft", function () {retorna isso. topLeft}), isto .__ defineGetter __ ("TopRight", função () {return this.topRight})} função FinderPatternFinder () {this.image = null, this.possibleCenters = [], this.hasSkipped =! 1, this. crossCheckStateCount = new Array (0,0,0,0,0), this.resultPointCallback = null, isto .__ defineGetter __ ("CrossCheckStateCount", function () {retornar this.crossCheckStateCount [0] = 0, this.crossCheckStateCount [1] = 0, this.crossCheckStateCount [2] = 0, this.crossCheckStateCount [3] = 0, this.crossCheckStateCount [4] = 0, this.crossCheckStateCount}), this.foundPatternCross = function (stateCount) {para (var totalModuleSize = 0, i = 0; 5> i; i ++) {var count = stateCount [i]; if (0 == contagem) retorna! 1;totalModuleSize + = count} if (7> totalModuleSize) return! 1; var moduleSize = Math.floor ((totalModuleSize << INTEGER_MATH_SHIFT) / 7), maxVariance = Math.floor (moduleSize / 2); retorne Math.abs (moduleSize- () stateCount [0] << INTEGER_MATH_SHIFT)) <maxVariance && Math.abs (moduleSize- (estadoContagem [1] << INTEGER_MATH_SHIFT)) <maxVariance && Math.abs (3 * moduleSize- (stateCount [2] << INTEGER_MATH_SHIFT)) <3 * maxVariance && Math. abs (moduleSize- (stateCount [3] << INTEGER_MATH_SHIFT)) <maxVariance && Math.abs (moduleSize- (stateCount [4] << INTEGER_MATH_SHIFT)) <maxVariance}, this.centerFromEnd = função (stateCount, end) {retornar end-stateCount [4] -stateCount [3] -stateCount [2] / 2}, this.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {para (var image = this.image, maxI = qrcode.height, stateCount = this .CrossCheckStateCount, i = startI; i> = 0 && imagem [centerJ + i * qrcode.width];) stateCount [2] ++, i -; if (0> i) retorna NaN; para (; i> = 0 &&! Image [centerJ + i * qrcode.width] && stateCount [1] <= maxCount;) stateCount [1] ++, i -; if (0> i || stateCount [1]> maxCount) retorna NaN; para (; i > = 0 && image [centerJ + i * qrcode.width] && stateCount [0] <= maxCount;) stateCount [0] ++, i -; if (stateCount [0]> maxCount) retorna NaN; para (i = startI + 1; maxI> i && imagem [centerJ + i * qrcode.width];) stateCount [2] ++, i ++; if (i == maxI) retorna NaN; para (; maxI> i &&! Image [centerJ + i * qrcode. width] && stateCount [3] <maxCount;) stateCount [3] ++, i ++; if (i == maxI || stateCount [3]> = maxCount) retorna NaN; para (; maxI> i && imagem [centerJ + i * qrcode .width] && stateCount [4] <maxCount;) stateCount [4] ++, i ++; if (stateCount [4]> = maxCount) retorna NaN;var stateCountTotal = stateCount [0] + stateCount [1] + stateCount [2] + stateCount [3] + stateCount [4]; retorno 5 * Math.abs (stateCountTotal-originalStateCountTotal)> = 2 * originalStateCountTotal? NaN: this.foundPatternCross (stateCount)? this.centerFromEnd (stateCount, i): NaN}, this.crossCheckHorizontal = função (startJ, centerI, maxCount, originalStateCountTotal) {para (var image = this.image, maxJ = qrcode.width, stateCount = this. CrossCheckStateCount, j = startJ; j> = 0 && imagem [j + centerI * qrcode.width];) stateCount [2] ++, j -; se (0> j) retorna NaN; para (; j> = 0 &&! Image [j + centerI * qrcode.width] && stateCount [1] <= maxCount;) stateCount [1] ++, j -; if (0> j || stateCount [1]> maxCount) retorna NaN; para (; j > = 0 && imagem [j + centerI * qrcode.width] && stateCount [0] <= maxCount;) stateCount [0] ++, j -; if (stateCount [0]> maxCount) retorna NaN; para (j = startJ + 1; maxJ> j &&image [j + centerI * qrcode.width];) stateCount [2] ++, j ++; if (j == maxJ) retorna NaN; para (; maxJ> j &&! imagem [j + centerI * qrcode.width] && stateCount [ 3] <maxCount;) stateCount [3] ++, j ++; if (j == maxJ || stateCount [3]> = maxCount) retorna NaN; para (; maxJ> j && imagem [j + centerI * qrcode.width] && stateCount [4] <maxCount;) stateCount [4] ++, j ++; if (valor de stateCount [4]> = maxCount) NaN; var stateCountTotal = stateCount [0] + estadoContagem [1] + estadoContagem [2] + estadoContagem [3 ] + stateCount [4]; return 5 * Math.abs (stateCountTotal-originalStateCountTotal)> = originalStateCountTotal? NaN: this.foundPatternCross (stateCount)? this.centerFromEnd (stateCount, j): NaN}, this.handlePossibleCenter = function (stateCount , ie, j) {var stateCountTotal = stateCount [0] + stateCount [1] + stateCount [2] + stateCount [3] + stateCount [4], centerJ = this.centerFromEnd (stateCount, j), centerI = this.crossCheckVertical (i, matemática.floor (centerJ), stateCount [2], stateCountTotal), if (! isNaN (centerI) && (centerJ = this.crossCheckHorizontal (Math.floor (centerJ), Math.floor (centerI), stateCount [2], stateCountTotal), ! isNaN (centerJ))) {para (var estimatedModuleSize = stateCountTotal / 7, encontrado =! 1, max = this.possibleCenters.length, índice = 0; max> índice; índice ++) {var center = this.possibleCenters [index] if (center.aboutEquals (estimatedModuleSize, centerI, centerJ)) {center.incrementCount (), encontrado =! 0; break}} if (! encontrado) {var point = new FinderPattern (centerJ, centerI, estimatedModuleSize); possibleCenters.push (point), null! = this.resultPointCallback && this.resultPointCallback.foundPossibleResultPoint (point)} return! 0} return! 1}, this.selectBestPatterns = function () {var startSize = this.possibleCenters.length; if (3 > startSize) throw "Não foi possível encontrar padrões de localização suficientes"; if (startSize>3) {para (var totalModuleSize = 0, i = 0; startSize> i; i ++) totalModuleSize + = this.possibleCenters [i] .EstimatedModuleSize; para (var average = totalModuleSize / startSize, i = 0; i <this.possibleCenters. length && this.possibleCenters.length> 3; i ++) {var padrão = this.possibleCenters [i]; Math.abs (pattern.EstimatedModuleSize-average)>. 2 * média && (this.possibleCenters.remove (i), i--) }} return this.possibleCenters.Count> 3, novo Array (this.possibleCenters [0], this.possibleCenters [1], this.possibleCenters [2])}, this.findRowSkip = function () {var max = isto. possibleCenters.length; if (1> = max) retorna 0; para (var firstConfirmedCenter = null, i = 0; máx> i; i ++) {var center = este.possívelCenters [i]; if (center.Count> = CENTER_QUORUM ) {if (null! = firstConfirmedCenter) retorna this.hasSkipped =! 0, Math.floor ((Math.abs (firstConfirmedCenter.X-center.X) -Math.abs (firstConfirmedCenter).Y-center.Y)) / 2); firstConfirmedCenter = center}} retornar 0}, this.haveMultiplyConfirmedCenters = function () {para (var confirmedCount = 0, totalModuleSize = 0, max = this.possibleCenters.length, i = 0 ; max> i; i ++) {var padrão = this.possibleCenters [i]; pattern.Count> = CENTER_QUORUM && (confirmedCount ++, totalModuleSize + = padrão.EstimatedModuleSize)} if (3> confirmedCount) retornar! 1; para (var average = totalModuleSize /max,totalDeviation=0,i=0;max>i;i++)pattern=this.possibleCenters[i],totalDeviation+=Math.abs(pattern.EstimatedModuleSize-average);return.05*totalModuleSize>=totalDeviation}, this .findFinderPattern = função (imagem) {var tryHarder =! 1; this.image = imagem; var maxI = qrcode.height, maxJ = qrcode.width, iSkip = Math.floor (3 * maxI / (4 * MAX_MODULES)); (MIN_SKIP> iSkip || tryHarder) && (iSkip = MIN_SKIP); para (var done =! 1, stateCount = novo Array (5), i = iSkip-1; maxI> i &&!feito; i + = iSkip) {stateCount [0] = 0, stateCount [1] = 0, stateCount [2] = 0, estadoContato [3] = 0, estadoContato [4] = 0; para (var currentState = 0, j = 0; maxJ> j; j ++) if (imagem [j + i * qrcode.width]) 1 == (1 & currentState) && currentState ++, stateCount [currentState] ++; else if (0 == (1 & currentState)) if (4 == currentState) if (this.foundPatternCross (stateCount)) {var confirmado = this.handlePossibleCenter (stateCount, i, j); if (confirmado) if (iSkip = 2, this.hasSkipped) feito = this.haveMultiplyConfirmedCenters (); else {var rowSkip = this.findRowSkip (); rowSkip> stateCount [2] && (i + = rowSkip-stateCount [2] -iSkip, j = maxJ-1)} mais {do j ++; while (maxJ> j &&! imagem [ j + i * qrcode.width]); j -} currentState = 0, stateCount [0] = 0, estadoCount [1] = 0, stateCount [2] = 0, stateCount [3] = 0, stateCount [4] = 0} outra stateCount [0] = stateCount [2], stateCount [1] = stateCount [3], stateCount [2] = stateCount [4], stateCount [3] = 1, stateCount [4] = 0,currentState = 3; senão stateCount [++ currentState] ++; else stateCount [currentState] + +; if (this.foundPatternCross (stateCount)) {var confirmado = this.handlePossibleCenter (stateCount, i, maxJ); confirmado && (iSkip = stateCount [0], this.hasSkipped && (done = haveMultiplyConfirmedCenters ()))}} var patternInfo = this.selectBestPatterns (); retorno qrcode.orderBestPatterns (patternInfo), nova função FinderPatternInfo (patternInfo)}} AlignmentPattern (posX, posY, estimatedModuleSize ) {this.x = posX, this.y = posY, this.count = 1, this.estimatedModuleSize = estimatedModuleSize, isto .__ defineGetter __ ("EstimatedModuleSize", function () {retorne this.estimatedModuleSize}), isto .__ defineGetter __ (" Count ", function () {return this.count}), isto .__ defineGetter __ (" X ", function () {retorna Math.floor (this.x)}), isto .__ defineGetter __ (" Y ", function () { retornar Math.floor (this.y)}), this.incrementCount = function () {this.count ++}, this.aboutEquals = function (moduleSize, i, j) {se (Math.abs (i-this.y) <= moduleSize && Math .abs (j-this.x) <= moduleSize) {var moduleSizeDiff = Math.abs (moduleSize-this.estimatedModuleSize); retorno 1> = moduleSizeDiff || moduleSizeDiff / this.estimatedModuleSize <= 1} função return! 1}} AlignmentPatternFinder (imagem, startX, startY, largura, altura, moduleSize, resultPointCallback) {this.image = image, this.possibleCenters = new Matriz, this.startX = startX, this.startY = startY, this.width = width, this. height = height, this.moduleSize = moduleSize, this.crossCheckStateCount = new Matriz (0,0,0), this.resultPointCallback = resultPointCallback, this.centerFromEnd = função (stateCount, end) {retornar end-stateCount [2] -stateCount [1] / 2}, this.foundPatternCross = function (stateCount) {para (var moduleSize = this.moduleSize, maxVariance = moduleSize / 2,i = 0; 3> i; i ++) if (Math.abs (moduleSize-stateCount [i])> = maxVariance) retorno! 1; retorno! 0}, this.crossCheckVertical = função (startI, centerJ, maxCount, originalStateCountTotal) {var image = this.image, maxI = qrcode.height, stateCount = this.crossCheckStateCount; stateCount [0] = 0, stateCount [1] = 0, stateCount [2] = 0; para (var i = startI; i> = 0 && imagem [centerJ + i * qrcode.width] && stateCount [1] <= maxCount;) stateCount [1] ++, i -; if (0> i || stateCount [1]> maxCount) retorna NaN; para ( ; i> = 0 &&! imagem [centerJ + i * qrcode.width] && stateCount [0] <= maxCount;) stateCount [0] ++, i -; if (stateCount [0]> maxCount) retorna NaN; para ( i = startI + 1; maxI> i && imagem [centerJ + i * qrcode.width] && stateCount [1] <= maxCount;) stateCount [1] ++, i ++; if (i == maxI || stateCount [1]> maxCount ) NaN; para (; maxI> i &&! image [centerJ + i * qrcode.width] &&stateCount [2] <= maxCount;) stateCount [2] ++, i ++; if (valor de stateCount [2]> maxCount) NaN; var stateCountTotal = stateCount [0] + stateCount [1] + stateCount [2]; retorno 5 * Math.abs (stateCountTotal-originalStateCountTotal)> = 2 * originalStateCountTotal? NaN: this.foundPatternCross (stateCount)? This.centerFromEnd (stateCount, i): NaN}, this.handlePossibleCenter = function (stateCount, i, j) {var stateCountTotal = stateCount [0] + stateCount [1] + stateCount [2], centerJ = this.centerFromEnd (stateCount, j), centerI = this.crossCheckVertical (i, Math.floor (centerJ), 2 * stateCount [1], stateCountTotal); if (! isNaN (centerI)) {para (var estimatedModuleSize = (stateCount [0] + estadoCount [1] + stateCount [2]) / 3, max = this.possibleCenters.length, índice = 0; max> index; index ++) {var center = este.possívelCenters [index]; if (center.aboutEquals (estimatedModuleSize, centerI, centerJ)) retorna o novo AlignmentPattern (centerJ, centerI,estimatedModuleSize)} var point = new AlignmentPattern (centerJ, centerI, estimatedModuleSize); this.possibleCenters.push (point), null! = this.resultPointCallback && this.resultPointCallback.foundPossibleResultPoint (point)} retornar null}, this.find = function () {para (var startX = this.startX, altura = this.height, maxJ = startX + largura, middleI = startY + (altura >> 1), stateCount = new Matriz (0,0,0), iGen = 0; altura> iGen; iGen ++) {var i = middleI + (0 == (1 e iGen)? iGen + 1 >> 1 :-( iGen + 1 >> 1)); stateCount [0] = 0, stateCount [1] = 0, stateCount [2] = 0; para (var j = startX; maxJ> j &&! Imagem [j + qrcode.width * i];) j ++; para (var currentState = 0; maxJ> j;) {if (imagem [j + i * qrcode.width]) if (1 == currentState) stateCount [estado atual] ++; else if (2 == currentState) {if (this.foundPatternCross (stateCount)) {var confirmado = this.handlePossibleCenter (stateCount, i j) se (null!= confirmado) return confirmed} stateCount [0] = stateCount [2], stateCount [1] = 1, stateCount [2] = 0, currentState = 1} mais stateCount [++ currentState] ++; else 1 == currentState && currentState ++, stateCount [currentState] ++; j ++} if (this.foundPatternCross (stateCount)) {var confirmado = this.handlePossibleCenter (stateCount, i, maxJ); se (null! = confirmado) retorno confirmado}} if (0! = this .possibleCenters.length) return this.possibleCenters [0]; throw "Não foi possível encontrar padrões de alinhamento suficientes"}} QRCodeDataBlockReader (blocos, versão, numErrorCorrectionCode) {this.blockPointer = 0, this.bitPointer = 7, this.dataLength = 0, this.blocks = blocos, this.numErrorCorrectionCode = numErrorCorrectionCode, 9> = versão? This.dataLengthMode = 0: versão> = 10 && 26> = versão? This.dataLengthMode = 1: versão> = 27 && 40> = versão && (this. dataLengthMode = 2), isso.getNextBits = function (numBits) {var bits = 0; se (numBits <this.bitPointer + 1) {para (var mask = 0, i = 0; numBits> i; i ++) mascarar + = 1 << i; <= this.bitPointer-numBits + 1, bits = (this.blocks [this.blockPointer] e máscara) >> this.bitPointer-numBits + 1, this.bitPointer- = numBits, bits} if (numBits <this.bitPointer + 1 + 8) {para (var mask1 = 0, i = 0; i <this.bitPointer + 1; i ++) mask1 + = 1 << i; bits de retorno = (this.blocks [this.blockPointer] & mask1) << numBits - (this.bitPointer + 1), this.blockPointer ++, bits + = this.blocks [this.blockPointer] >> 8- (numBits- (this.bitPointer + 1)), this.bitPointer = this.bitPointer-numBits% 8 , this.bitPointer <0 && (this.bitPointer = 8 + this.bitPointer), bits} if (numBits <this.bitPointer + 1 + 16) {para (var mask1 = 0, mask3 = 0, i = 0; i < this.bitPointer + 1; i ++) mask1 + = 1 << i; var bitsFirstBlock = (this.blocks [this.blockPointer] e mask1) <<numBits- (this.bitPointer + 1); this.blockPointer ++; var bitsSegundoBlock = this.blocks [this.blockPointer] << numBits- (this.bitPointer + 1 + 8); this.blockPointer ++; para (var i = 0; i <numBits- (this.bitPointer + 1 + 8); i ++) mask3 + = 1 << i; mask3 << = 8- (numBits- (this.bitPointer + 1 + 8)); var bitsThirdBlock = (this.blocks [this.blockPointer] & mask3) >> 8- (numBits- (this.bitPointer + 1 + 8)); bits de retorno = bitsFirstBlock + bitsSecondBlock + bitsThirdBlock, this.bitPointer = this.bitPointer- (numBits-8)% 8, this.bitPointer <0 && (this.bitPointer = 8 + this.bitPointer), bits} retornar 0}, this.NextMode = function () {retornar this.blockPointer> this.blocks.length-this.numErrorCorrectionCode-2? 0: this.getNextBits (4)}, this.getDataLength = function (modeIndicator) {para (var index = 0 ;;) {if (modoIndicador >> índice == 1) quebra; índice ++} return this.getNextBits (qrcode.sizeOfDataLengthInfo [ isto.dataLengthMode] [index])}, this.getRomanAndFigureString = função (dataLength) {var length = dataLength, intData = 0, strData = "", tableRomanAndFigure = nova matriz ("0", "1", "2", "3 "," 4 "," 5 "," 6 "," 7 "," 8 "," 9 "," A "," B "," C "," D "," E "," F ", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S "," T "," U "," V "," W "," X "," Y "," Z "," "," $ ","% "," * "," + "," - ",". "," / ",": "); do if (comprimento> 1) {intData = this.getNextBits (11); var firstLetter = Matemática.floor (intData / 45), secondLetter = intData% 45; strData + = tableRomanAndFigure [firstLetter], strData + = tableRomanAndFigure [secondLetter], comprimento- = 2} mais 1 == comprimento && (intData = this.getNextBits (6), strData + = tableRomanAndFigure [intData], length- = 1); while (comprimento> 0); return strData}, this.getFigureString = função (dataLength) {var length = dataLength, intData = 0, strData = ""; do comprimento> = 3? (intData = this.getNextBits (10), 100> intData && (strData + = "0"), 10> intData && (strData + = "0"), comprimento- = 3): 2 == comprimento? (intData = this.getNextBits ( 7), 10> intData && (strData + = "0"), comprimento- = 2): 1 == comprimento && (intData = this.getNextBits (4), comprimento- = 1), strData + = intData; while (comprimento> 0) ; return strData}, this.get8bitByteArray = função (dataLength) {var length = dataLength, intData = 0, saída = novo Array; do intData = this.getNextBits (8),output.push (intData), length -; while (comprimento> 0); retorno de saída}, this.getKanjiString = function (dataLength) {var comprimento = dataLength, intData = 0, unicodeString = ""; do {intData = getNextBits (13); var lowerByte = intData% 192, higherByte = intData / 192, tempWord = (maiorByte << 8) + lowerByte, shiftjisWord = 0; shiftjisWord = 40956> = tempWord + 33088? TempWord + 33088: tempWord + 49472, unicodeString + = String.fromCharCode (shiftjisWord), comprimento -} while (comprimento> 0); retorno unicodeString}, isto .__ defineGetter __ ("DataByte", function () {para (var output = new Array, MODE_NUMBER = 1, MODE_ROMAN_AND_NUMBER = 2 , MODE_8BIT_BYTE = 4, MODE_KANJI = 8 ;;) {var mode = this.NextMode (); if (0 == modo) {if (output.length> 0) quebra; lance "Bloco de dados vazio"} if (modo! = MODE_NUMBER && mode! = MODE_ROMAN_AND_NUMBER && mode! = MODE_8BIT_BYTE && mode! = MODE_KANJI) lançar "Modo inválido:"+ mode + "in (bloco:" + this.blockPointer + "bit:" + this.bitPointer + ")"; if (dataLength = this.getDataLength (modo), dataLength <1) throw "Comprimento de dados inválido:" + dataLength; (mode) {case MODE_NUMBER: para (var temp_str = this.getFigureString (dataLength), ta = novo Array (temp_str.length), j = 0; j <temp_str.length; j ++) ta [j] = temp_str.charCodeAt ( j); output.push (ta); break; case MODE_ROMAN_AND_NUMBER: para (var temp_str = this.getRomanAndFigureString (dataLength), ta = novo Array (temp_str.length), j = 0; j <temp_str.length; j ++) ta [j] = temp_str.charCodeAt (j); output.push (ta); break; caso MODE_8BIT_BYTE: var temp_sbyteArray3 = this.get8bitByteArray (dataLength); output.push (temp_sbyteArray3); quebra; caso MODE_KANJI: var temp_str = isto. getKanjiString (dataLength); output.push (temp_str)}} retornar saída})} GridSampler = {}, GridSampler.checkAndNudgePoints = function (image,pontos) {para (var width = qrcode.width, altura = qrcode.height, nudged =! 0, offset = 0; deslocamento <points.Length && nudged; offset + = 2) {var x = Math.floor (pontos [offset]) , y = Math.floor (pontos [offset + 1]); se (-1> x || x> largura || -1> y || y> altura) lance "Error.checkAndNudgePoints"; nudged =! 1, -1 == x? (Pontos [offset] = 0, nudged =! 0): x == largura && (pontos [offset] = largura-1, nudged =! 0), - 1 == y? (Pontos [offset] +1] = 0, nudged =! 0): y == height && (pontos [offset + 1] = altura-1, pressionado =! 0)} nudged =! 0; para (var offset = points.Length-2; offset> = 0 && nudged; offset- = 2) {var x = Math.floor (pontos [offset]), y = Math.floor (pontos [offset + 1]), se (-1> x || x> largura | | -1> y || y> altura) throw "Error.checkAndNudgePoints"; nudged =! 1, -1 == x? (Pontos [offset] = 0, nudged =! 0): x == largura && (pontos [ offset] = largura-1, nudged =! 0), - 1 == y? (pontos [offset + 1] = 0, nudged =! 0): y == altura &&(pontos [offset + 1] = altura-1, nudged =! 0)}}, GridSampler.sampleGrid3 = função (imagem, dimensão, transformação) {para (var bits = new BitMatrix (dimensão), pontos = new Array (dimensão << 1), y = 0; dimensão> y; y ++) {para (var max = pontos.length, iValor = y + .5, x = 0; máx> x; x + = 2) pontos [x] = (x >> 1) +. 5, pontos [x + 1] = iValue; transform.transformPoints1 (pontos), GridSampler.checkAndNudgePoints (imagem, pontos); tente {para (var x = 0; max> x; x + = 2) {var xpoint = 4 * Math.floor (pontos [x]) + Math.floor (pontos [x + 1]) * qrcode.width * 4, bit = imagem [Math.floor (pontos [x]) + qrcode. largura * Math.floor (pontos [x + 1])]; qrcode.imagedata.data [ponto x] = bit? 255: 0, qrcode.imagedata.data [xpoint + 1] = bit? 255: 0, qrcode.imagedata .data [xpoint + 2] = 0, qrcode.imagedata.data [xpoint + 3] = 255, bit && bits.set_Renamed (x >> 1, y)}} pegar (aioobe) {lançar "Error.checkAndNudgePoints"}} retornar bits}, GridSampler.sampleGridx = função (imagem, dimensão, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {var transformada = PerspectiveTransform.quadrilateralToQuadrilateral (p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY); retorno GridSampler.sampleGrid3 (imagem, dimens, transforma)}, Version.VERSION_DECODE_INFO = new Array (31892,34236,39577,42195,48118,51042,55367,58893,63784,68472,70749,76311,79154,84390,87683,92361,96236,102084,102881,110507,110734,117786,119615,126325,127568 , 133589,136944,141498,145311,150283,152622,158308,161089,167017), Versão.VERSIONS = buildVersions (), Version.getVersionForNumber = function (versionNumber) {if (1> versionNumber || versionNumber> 40) throw " ArgumentException "; return Version.VERSIONS [versionNumber-1]}, Versão.getProvisionalVersionForDimension = função (dimensão) {if (dimensão% 4! = 1) lance "Erro getProvisionalVersionForDimension"; tente {retornar Version.getVersionForNumber (dimensão-17 >> 2)} catch (iae) {throw "Erro getVersionForNumber"}}, Version.decodeVersionInformation = function (versionBits) {para (var bestDifference = 4294967295, bestVersion = 0, i = 0; i <versão.VERSION_DECODE_INFO.length; i ++) {var targetVersion = versão.VERSION_DECODE_INFO [i]; if (targetVersion == versionBits) return this.getVersionForNumber (i + 7); var bitsDiferença = FormatInformation.numBitsDiffering (versionBits, targetVersion); bestDifference> bitsDiferença && (bestVersion = i + 7, bestDifference = bitsDiferença)} return 3> = bestDifference? this.getVersionForNumber (bestVersion ): null}, PerspectiveTransform.quadrilateralToQuadrilateral = função (x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p,x2p, y2p, x3p, y3p) {var qToS = this.quadrilateralToSquare (x0, y0, x1, y1, x2, y2, x3, y3), sPara = this.squareToQuadrilateral (x0p, y0p, x1p, y1p, x2p, y2p , x3p, y3p); retorno sToQ.times (qToS)}, PerspectiveTransform.squareToQuadrilateral = function (x0, y0, x1, y1, x2, y2, x3, y3) {retorno dy2 = y3-y2, dy3 = y0-y1 + y2-y3,0 == dy2 && 0 == dy3? new PerspectiveTransform (x1-x0, x2-x1, x0, y1-y0, y2-y1, y0,0,0,1) :( dx1 = x1-x2, dx2 = x3-x2, dx3 = x0-x1 + x2-x3, d1 = y1-y2, denominador = dx1 * dy2-dx2 * dy1, a13 = (dx3 * d2-dx2 * dy3) / denominador, a23 = (dx1 * dy3-dx3 * dy1) / denominador, novo PerspectiveTransform (x1-x0 + a13 * x1, x3-x0 + a23 * x3, x0, y1-y0 + a13 * y1, y3-y0 + a23 * y3, y0, a13 , a23,1))}, PerspectiveTransform.quadrilateralToSquare = function (x0, y0, x1, y1, x2, y2, x3, y3) {retorne this.squareToQuadrilateral (x0, y0, x1, y1, x2, y2, x3, y3) .buildAdjoint ()}; var FORMAT_INFO_MASK_QR = 21522, FORMAT_INFO_DECODE_LOOKUP = nova Matriz (nova Matriz (21522,0), nova Matriz (20773,1),novo Array (24188,2), novo Array (23371,3), novo Array (17913,4), novo Array (16590,5), novo Array (20375,6), novo Array (19104,7), novo Array (30660,8), nova Matriz (29427,9), nova Matriz (32170,10), nova Matriz (30877,11), nova Matriz (26159,12), nova Matriz (25368,13), nova Matriz (27713) , 14), novo Array (26998,15), novo Array (5769,16), novo Array (5054,17), novo Array (7399,18), novo Array (6608,19), novo Array (1890,20 ), novo Array (597,21), novo Array (3340,22), novo Array (2107,23), novo Array (13663,24), novo Array (12392,25), novo Array (16177,26), novo Matriz (14854,27), novo Matriz (9396,28), novo Matriz (8579,29), novo Matriz (11994,30), novo Matriz (11245,31)), BITS_SET_IN_HALF_BYTE = novo Matriz (0,1, 1,2,1,2,2,3,1,2,2,3,2,3,3,4); FormatInformation.numBitsDiffering = function (a, b) {retornar a ^ = b, BITS_SET_IN_HALF_BYTE [15 & a] + BITS_SET_IN_HALF_BYTE [15 & URShift (a, 4)] + BITS_SET_IN_HALF_BYTE [15 & URShift (a, 8)] + BITS_SET_IN_HALF_BYTE [15 & URShift (a, 8)] + BITS_SET_IN_HALF_BYTE [15 & URShift (a, 8)]URShift (a, 12)] + BITS_SET_IN_HALF_BYTE [15 & URShift (a, 16)] + BITS_SET_IN_HALF_BYTE [15 e URShift (a, 20)] + BITS_SET_IN_HALF_BYTE [15 e URShift (a, 24)] + BITS_SET_IN_HALF_BYTE [15 & URShift (a, 28)]}, FormatInformation .decodeFormatInformation = function (maskedFormatInfo) {var formatInfo = FormatInformation.doDecodeFormatInformation (maskedFormatInfo); retorno null! = formatInfo? formatInfo: FormatInformation.doDecodeFormatInformation (mascaradoFormatInfo ^ FORMAT_INFO_MASK_QR)}, FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo) {para (var bestDifference = 4294967295, bestFormatInfo = 0, i = 0; i <FORMAT_INFO_DECODE_LOOKUP.length; i ++) {var decodeInfo = FORMAT_INFO_DECODE_LOOKUP [i], targetInfo = decodeInfo [0]; if (targetInfo == maskedFormatInfo) retorna novo FormatInformation (decodeInfo [1]) ; var bitsDifference = this.numBitsDiffering (maskedFormatInfo, targetInfo); bestDifference>bitsDifference && (bestFormatInfo = decodeInfo [1], bestDifference = bitsDiferença)} return 3> = bestDifference? new FormatInformation (bestFormatInfo): null}, ErrorCorrectionLevel.forBits = função (bits) {if (0> bits || bits> = FOR_BITS. Length) throw "ArgumentException"; retorne FOR_BITS [bits]}; var L = new ErrorCorrectionLevel (0,1, "L"), M = novo ErrorCorrectionLevel (1,0, "M"), Q = novo ErrorCorrectionLevel (2, 3, "Q"), H = novo ErrorCorrectionLevel (3,2, "H"), FOR_BITS = novo Array (M, L, H, Q), DataBlock.getDataBlocks = função (rawCodewords, versão, ecLevel) {if ( rawCodewords.length! = version.TotalCodewords) throw "ArgumentException"; para (var ecBlocks = versão.getECBlocksForLevel (ecLevel), totalBlocks = 0, ecBlockArray = ecBlocks.getECBlocks (), i = 0; i <ecBlockArray.length; i ++) totalBlocks + = ecBlockArray [i] .Count;para (var result = new Array (totalBlocks), numResultBlocks = 0, j = 0; j <ecBlockArray.length; j ++) para (var ecBlock = ecBlockArray [j], i = 0; i <ecBlock.Count; i ++) { var numDataCodewords = ecBlock.DataCodewords, numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords; resultado [numResultBlocks ++] = novo DataBlock (numDataCodewords, new Array (numBlockCodewords))} para (var shortBlocksTotalCodewords = result [0] .codewords.length, longerBlocksStartAt = result. length-1; longerBlocksStartAt> = 0;) {var numCodewords = resultado [longerBlocksStartAt] .codewords.length; if (numCodewords == shortBlocksTotalCodewords) quebra; longerBlocksStartAt -} longerBlocksStartAt ++; para (var shortBlocksNumDataCodewords = shortBlocksTotalCodewords-ecBlocks.ECCodewordsPerBlock, rawCodewordsOffset = 0, i = 0; shortBlocksNumDataCodewords> i; i ++) para (var j = 0; numResultBlocks> j; j ++) result [j].codewords [i] = rawCodewords [rawCodewordsOffset ++]; para (var j = longerBlocksStartAt; numResultBlocks> j; j ++) resultado [j] .codewords [shortBlocksNumDataCodewords] = rawCodewords [rawCodewordsOffset ++]; para (var max = result [0] .codewords. length, i = shortBlocksNumDataCodewords; max> i; i ++) para (var j = 0; numResultBlocks> j; j ++) {var iOffset = longerBlocksStartAt> j? i: i + 1; resultado [j] .codewords [iOffset] = rawCodewords [rawCodewordsOffset ++]} retornar resultado}, DataMask = {}, DataMask.forReference = function (reference) {if (referência 0 || referência> 7) lançar "System.ArgumentException"; retornar DataMask.DATA_MASKS [reference]}, DataMask .DATA_MASKS = novo Array (novo DataMask000, novo DataMask001, novo DataMask010, novo DataMask011, novo DataMask100, novo DataMask101, novo DataMask110, novo DataMask111), GF256.QR_CODE_FIELD = novo GF256 (285), GF256.DATA_MATRIX_FIELD = novo GF256 (301) GF256addOrSubtract = function (a, b) {retorno a ^ b}, Decoder = {}, Decoder.rsDecoder = novo ReedSolomonDecoder (GF256.QR_CODE_FIELD), Decoder.correctErrors = function (codewordBytes, numDataCodewords) {para (var numCodewords = codewordBytes. length, codewordsInts = new Matriz (numCodewords), i = 0; numCodewords> i; i ++) codewordsInts [i] = 255 & codewordBytes [i]; var numECCodecords = codewordBytes.length-numDataCodewords; try {Decoder.rsDecoder.decode (codewordsInts, numECCodewords }} catch (rse) {throw rse} para (var i = 0; numDataCodewords> i; i ++) codewordBytes [i] = codewordsInts [i]}, Decoder.decode = function (bits) {para (var parser = new BitMatrixParser (bits), versão = parser.readVersion (), ecLevel = parser.readFormatInformation (). ErrorCorrectionLevel, codewords = parser.readCodewords (), dataBlocks = DataBlock.getDataBlocks (palavras de código, versão, ecLevel), totalBytes = 0, i = 0 i <dataBlocks.Length; i ++) totalBytes + = dataBlocks [i].NumDataCodewords; para (var resultBytes = new Matriz (totalBytes), resultOffset = 0, j = 0; j <dataBlocks.length; j ++) {var dataBlock = dataBlocks [j], codewordBytes = dataBlock.Codewords, numDataCodewords = dataBlock.NumDataCodewords; Decoder.correctErrors (codewordBytes, numDataCodewords); para (var i = 0; numDataCodewords> i; i ++) resultBytes [resultOffset ++] = codewordBytes [i]} var reader = novo QRCodeDataBlockReader (resultBytes, version.VersionNumber, ecLevel.Bits); reader}, qrcode = {}, qrcode.imagedata = null, qrcode.width = 0, qrcode.height = 0, qrcode.qrCodeSymbol = null, qrcode.debug =! 1, qrcode.sizeOfDataLengthInfo = [[10,9,8 , 8], [12,11,16,10], [14,13,16,12]], qrcode.callback = null, qrcode.decode = função (src) {if (0 == argumentos.length) { var canvas_qr = document.getElementById ("qr-canvas"), context = canvas_qr.getContext ("2d"); retorno qrcode.width = canvas_qr.width, qrcode.height = canvas_qr.height, qrcode.imagedata = context.getImageData (0,0, qrcode.width, qrcode.height), qrcode.result = qrcode.process (contexto), nulo! = qrcode.callback && qrcode.callback (qrcode.result ), qrcode.result} var image = novo Image; image.onload = function () {var canvas_qr = document.createElement ("canvas"), context = canvas_qr.getContext ("2d"), canvas_out = document.getElementById (" out-canvas "); if (null! = canvas_out) {var outctx = canvas_out.getContext (" 2d "); outctx.clearRect (0,0,320,240), outctx.drawImage (imagem, 0,0,320,240)} canvas_qr.width = image.width, canvas_qr.height = image.height, context.drawImage (imagem, 0,0), qrcode.width = image.width, qrcode.height = image.height; tentar {qrcode.imagedata = context.getImageData (0 , 0, image.width, image.height)} catch (e) {return qrcode.result = "Leitura de imagens de domínio cruzado não suportada em seu navegador!Salve no seu computador e arraste e solte o arquivo! ", Void (null! = Qrcode.callback && qrcode.callback (qrcode.result))} tente {qrcode.result = qrcode.process (contexto)} catch (e) {console .log (e), qrcode.result = "código de decodificação de erro QR"} null! = qrcode.callback && qrcode.callback (qrcode.result)}, image.src = src}, qrcode.decode_utf8 = função (s) {return decodeURIComponent (escape (s))}, qrcode.process = função (ctx) {var start = (nova data) .getTime (), imagem = qrcode.grayScaleToBitmap (qrcode.grayscale ()); if (qrcode.debug) {para (var y = 0; y <qrcode.height; y ++) para (var x = 0; x <qrcode.width; x ++) {var ponto = 4 * x + y * qrcode.width * 4; qrcode.imagedata.data [ponto] = (imagem [x + y * qrcode.width], 0), qrcode.imagedata.data [ponto + 1] = (imagem [x + y * qrcode.width], 0), qrcode.imagedata.data [ponto + 2] = imagem [x + y * qrcode.width]? 255: 0} ctx.putImageData (qrcode.imagedata, 0,0)} var detector = new Detector (imagem), qRCodeMatrix = detector.detect (); qrcode.debug && ctx.putImageData (qrcode.imagedata, 0,0); para (var reader = Decoder.decode (qRCodeMatrix.bits), data = reader.DataByte, str = "", i = 0; i <data.length; i ++) para (var j = 0; j <dados [i] .length; j ++) str + = String.fromCharCode (dados [i] [j]); var end = (new Date) .getTime (), tempo = end-start; return console.log (tempo), qrcode.decode_utf8 (str)}, qrcode.getPixel = function (x, y) { if (qrcode.width <x) lançará "erro de ponto", se (qrcode.height <y) lançar "erro de ponto", ponto de retorno = 4 * x + y * qrcode.width * 4, p = (33 * qrcode. imagedata.data [ponto] + 34 * qrcode.imagedata.data [ponto + 1] + 33 * qrcode.imagedata.data [ponto + 2]) / 100, p}, qrcode.binarize = function (th) {para ( var ret = new Matriz (qrcode.width * qrcode.height), y = 0; y <qrcode.height; y ++) para (var x = 0; x <qrcode.width; x ++) {var cinza = qrcode.getPixel ( x, y);ret [x + y * qrcode.width] = th> = cinza?! 0:! 1} return ret}, qrcode.getMiddleBrightnessPerArea = função (imagem) {para (var numSqrtArea = 4, areaWidth = Math.floor (qrcode. width / numSqrtArea), areaHeight = Math.floor (qrcode.height / numSqrtArea), minmax = novo Array (numSqrtArea), i = 0; numSqrtArea> i; i ++) {minmax [i] = novo Array (numSqrtArea); var i2 = 0; numSqrtArea> i2; i2 ++) minmax [i] [i2] = novo Matriz (0,0)} para (var ay = 0; numSqrtArea> ay; ay ++) para (var ax = 0; numSqrtArea> ax ; ax ++) {minmax [ax] [ay] [0] = 255; para (var dy = 0; areaHeight> dy; dy ++) para (var dx = 0; areaWidth> dx; dx ++) {var alvo = imagem [areaWidth * ax + dx + (áreaAltura * ay + dy) * qrcode.width]; alvo <minmax [axe] [aa] [0] && (minmax [ax] [ay] [0] = alvo), alvo> minmax [ax ] [ay] [1] && (minmax [ax] [ay] [1] = alvo)}} para (var médio = novo Array (numSqrtArea), i3 = 0; numSqrtArea> i3; i3 ++) meio [i3] = new Array (numSqrtArea), para (var ay = 0;numSqrtArea> ay; ay ++) para (var ax = 0; numSqrtArea> ax; ax ++) meio [ax] [ay] = Math.floor ((minmax [ax] [aa] [0] + minmax [ax] [ay] [1]) / 2); return no meio}, qrcode.grayScaleToBitmap = function (grayScale) {para (var middle = qrcode.getMiddleBrightnessPerArea (grayScale), sqrtNumArea = middle.length, areaWidth = Math.floor (qrcode.width / sqrtNumArea ), areaHeight = Math.floor (qrcode.height / sqrtNumArea), bitmap = novo Array (qrcode.height * qrcode.width), ay = 0; sqrtNumArea> ay; ay ++) para (var ax = 0; sqrtNumArea> ax; ax ++) para (var dy = 0; areaHeight> dy; d ++) para (var dx = 0; areaWidth> dx; dx ++) bitmap [areaWidth * ax + dx + (areaHeight * aa + dy) * qrcode.width] = grayScale [ areaWidth * axe + dx + (areaHeight * aa + dy) * qrcode.width] <meio [axe] [ay] ?! 0:! 1;grayScaleToBitmap = function (grayScale) {para (var middle = qrcode.getMiddleBrightnessPerArea (grayScale), sqrtNumArea = middle.length, areaWidth = Math.floor (qrcode.width / sqrtNumArea), areaHeight = Math.floor (qrcode.height / sqrtNumArea) , bitmap = new Matriz (qrcode.height * qrcode.width), ay = 0; sqrtNumArea> ay; ay ++) para (var ax = 0; sqrtNumArea> ax; ax ++) para (var dy = 0; areaHeight> dy; dy ++ ) para (var dx = 0; areaWidth> dx; dx ++) mapa de bits [areaWidth * ax + dx + (áreaHeight * ay + dy) * qrcode.width] = greyScale [areaWidth * ax + dx + (áreaHeight * ay + dy) * qrcode Largura] <meio [axe] [ay] ?! 0:! 1;grayScaleToBitmap = function (grayScale) {para (var middle = qrcode.getMiddleBrightnessPerArea (grayScale), sqrtNumArea = middle.length, areaWidth = Math.floor (qrcode.width / sqrtNumArea), areaHeight = Math.floor (qrcode.height / sqrtNumArea) , bitmap = new Matriz (qrcode.height * qrcode.width), ay = 0; sqrtNumArea> ay; ay ++) para (var ax = 0; sqrtNumArea> ax; ax ++) para (var dy = 0; areaHeight> dy; dy ++ ) para (var dx = 0; areaWidth> dx; dx ++) mapa de bits [areaWidth * ax + dx + (áreaHeight * ay + dy) * qrcode.width] = greyScale [areaWidth * ax + dx + (áreaHeight * ay + dy) * qrcode Largura] <meio [axe] [ay] ?! 0:! 1;dy ++) para (var dx = 0; areaWidth> dx; dx ++) mapa de bits [areaWidth * ax + dx + (areaHeight * aa + dy) * qrcode.width] = greyScale [areaWidth * ax + dx + (areaHeight * ay + dy) * qrcode.width] <meio [axe] [ay] ?! 0:! 1;dy ++) para (var dx = 0; areaWidth> dx; dx ++) mapa de bits [areaWidth * ax + dx + (areaHeight * aa + dy) * qrcode.width] = greyScale [areaWidth * ax + dx + (areaHeight * ay + dy) * qrcode.width] <meio [axe] [ay] ?! 0:! 1;
	bitmap de retorno}, qrcode.grayscale = function () {para (var ret = new Array (qrcode.width * qrcode.height), y = 0; y <qrcode.height; y ++) para (var x = 0; x < qrcode.width; x ++) {var cinza = qrcode.getPixel (x, y); ret [x + y * qrcode.width] = cinza} retornar ret}, Array.prototype.remove = function (from, to) {var rest = this.slice ((para || partir de) +1 || this.length); retornar this.length = 0> de? this.length + de: from, this.push.apply (isto, descanso)}; var MIN_SKIP = 3, MAX_MODULES = 57, INTEGER_MATH_SHIFT = 8, CENTER_QUORUM = 2, qrcode.orderBestPatterns = função (padrões) {função distance (pattern1, pattern2) {retorno xDiff = pattern1.X-pattern2.X, yDiff = pattern1.Y -pattern2.Y, Math.sqrt (xDiff * xDiff + yDiff * yDiff)} função crossProductZ (pontoA, pontoB, pontoC) {var bX = pontoB.x, bY = pontoB.y; retorno (pontoC.x-bX) * (pointA.y-bY) - (pointC.y-bY) * (pointA.x-bX)} var pointA, pointB, pointC, zeroOneDistância = distância (padrões [0], padrões [1]),oneTwoDistance = distance (patterns [1], padrões [2]), zeroTwoDistance = distance (padrões [0], padrões [2]); if (oneTwoDistance> = zeroOneDistance && oneTwoDistance> = zeroTwoDistance? (pointB = padrões [0], pontoA = patterns [1], pointC = patterns [2]): zeroDoisDistância> = umDoisDistância && zeroDoisDistância> = zeroOneDistância? (pontoB = padrões [1], ponto A = padrões [0], ponto C = padrões [2]) :( ponto B = padrões [2 ], ponto A = padrões [0], ponto C = padrões [1]), crossProductZ (ponto A, ponto B, ponto C) <0) {var temp = ponto A; ponto A = ponto C, ponto C = temp} padrões [0] = ponto A, padrões [1] = ponto B, padrões [2] = ponto C};zeroTwoDistance> = zeroOneDistance? (pontoB = padrões [1], ponto A = padrões [0], ponto C = padrões [2]) :( ponto B = padrões [2], ponto A = padrões [0], ponto C = padrões [1]) , crossProductZ (ponto A, ponto B, ponto C) <0) {var temp = ponto A; ponto A = ponto C, ponto C = temp} padrões [0] = ponto A, padrões [1] = ponto B, padrões [2] = ponto C};zeroTwoDistance> = zeroOneDistance? (pontoB = padrões [1], ponto A = padrões [0], ponto C = padrões [2]) :( ponto B = padrões [2], ponto A = padrões [0], ponto C = padrões [1]) , crossProductZ (ponto A, ponto B, ponto C) <0) {var temp = ponto A; ponto A = ponto C, ponto C = temp} padrões [0] = ponto A, padrões [1] = ponto B, padrões [2] = ponto C};